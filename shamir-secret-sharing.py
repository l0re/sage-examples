# vim: set fileencoding=UTF-8 filetype=python :
# This file was *autogenerated* from the file ./shamir-secret-sharing.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_216 = Integer(216); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8)#!/usr/bin/env sage

###############################################################################
# Copyright 2013, Thomas Lor√ºnser
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################

###
# globals
#

q = _sage_const_2 ; m = _sage_const_8    # GF(256)

n = _sage_const_7    # number shares
k = _sage_const_3    # threshold

s = _sage_const_216  # secret

F = GF(q**m, names=('a',)); (a,) = F._first_ngens(1)
R = PolynomialRing(F, names=('x',)); (x,) = R._first_ngens(1)

### 
# functions
#
def topoly(x, gen):
    """ converts a coefficient list together with a generator
        into a polynomial 
    """
    poly = _sage_const_0 
    coeff = list(bin(x)[_sage_const_2 :])
    coeff.reverse()
    for i, bit in enumerate(coeff):
        if bit == '1': poly += gen**i
    return poly

def tpa(x):
    """ short poly generation with global generator a
    """
    return topoly(x, a)

###
# main sim area
#

# setup and show the polynomial for shamir secret sharing
ssp = tpa(s)
for i in range(_sage_const_1 ,k):
    ssp += F.random_element() * x**i
print('Polynomial:', [i.int_repr() for i in ssp.coeffs()])


# evaluate polinomial at differnt points (shares)
shares = []
points = []
for i in range(_sage_const_1 ,n+_sage_const_1 ):
    shares.append([i,int(ssp(topoly(i,a)).int_repr())])
    points.append([topoly(i,a), ssp(topoly(i,a))])
print('Shares:')
for i,p in zip(shares,points):
    print(i)

# reconstruct with lag BWrange
coeffs = R.lagrange_polynomial(points).coeffs()
print('Reconstructed LG:', [i.int_repr() for i in coeffs])

# introduce malicious point
points[_sage_const_0 ][_sage_const_1 ] = _sage_const_1 

# reconstruct with berlekamp-welch
A = []
b = []
for point in points:
    xp = point[_sage_const_0 ]
    yp = point[_sage_const_1 ]
    A.append([_sage_const_1 , xp, xp**_sage_const_2 , xp**_sage_const_3 , -yp])
    b.append(yp*xp)

A = Matrix(A[:_sage_const_5 ])
b = vector(b[:_sage_const_5 ])

QE = A.solve_right(b)
Q = sum([c * x**i for i,c in enumerate(QE[:_sage_const_4 ])]); 
E = x + QE[-_sage_const_1 ]
P = Q.quo_rem(E)[_sage_const_0 ]

print('BW Polynomial', P)
print('Reconstructed BW:', [i.int_repr() for i in P.coeffs()])
